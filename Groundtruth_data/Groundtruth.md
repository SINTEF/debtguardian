# Groundtruth Data

The following files in this directory includes initial findings of technical debt in the Apache Batik, Apache JXPath and
Apache Airflow repositories.

## Technical Debt Types

The following technical debt were inspected through the repositories.

| Category                                       | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
|------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **Duplicated String literals**                 | It refers to the repetitive use of identical string literals scattered throughout the codebase. This practice can lead to inconsistencies and maintenance challenges, especially if the text needs to be updated or localized. It is more efficient to use a single constant or resource for such literals, which ensures uniformity and simplifies updates, thereby reducing technical debt. This approach not only cleans up the code but also makes it more manageable and less error-prone.                                                            |
| **Duplicated code blocks**                     | It refers to instances where the same or very similar code blocks appear in multiple locations within a software project. It can lead to maintenance challenges, as any change to the logic would need to be replicated across all instances to maintain consistency. It also increases the codebase size unnecessarily and can lead to bugs if the copies diverge over time. Refactoring to remove duplicated code, often by creating shared functions or classes, can reduce this debt, improving maintainability and reducing the potential for errors. |
| **Nested flow statements**                     | It refers to situations where control structures like loops or conditional statements (e.g., for, while, if-else) are placed within one another, often to several levels of depth. This nesting can lead to code that is difficult to read, understand, and maintain. It can make debugging challenging and increase the risk of errors, as understanding the logic flow becomes more complex with each added level. Minimizing the depth of nesting improves code readability and maintainability, thereby reducing technical debt.                       |
| **Collapsible "if" statements**                | It refers to scenarios where multiple sequential "if" statements are nested inside the other but could be combined into a more streamlined and efficient conditional structure. This nesting often occurs when different conditions are checked in a series of "if" statements, which can be simplified by using logical operators (AND, OR) to combine these conditions into a single "if" statement. Reducing the number of nested "if" statements can enhance code readability and maintainability and reduce complexity.                               |
| **Long method/Complex Class**                  | It refers to methods or classes in software that are overly long or complex. A method contains too many lines of code, or a class has too many responsibilities, violating principles like Single Responsibility and leading to code that's hard to understand, maintain, and test. Such methods or classes often encapsulate multiple functionalities, making them prone to bugs and difficult to modify. Simplifying these methods or breaking down complex classes into smaller, more cohesive units can enhance code readability and maintainability.  |
| **Long parameter list**                        | It refers to methods or functions with a high number of parameters, which can make the code difficult to understand and maintain. Such methods are often a sign that the function is doing too much or that the parameters could be grouped more logically. It is better to refactor these methods, e.g., by using objects to encapsulate related parameters.                                                                                                                                                                                              |
| **Too many lines in switch case**              | It refers to excessively lengthy code within a switch statement, which can lead to decreased readability and maintainability (challenging to navigate and understand the switch logic). Best practices suggest keeping code within switch cases concise while delegating complex tasks to separate methods. Simplifying switch statements not only enhances code clarity but also helps debug and modify code.                                                                                                                                             |
| **Poor Code Formatting**                       | It emphasizes the importance of code readability and organization. This principle advocates for proper indentation, limiting the length of each line in the code and avoiding multiple declarations or statements on a single line. Adhering to this practice enhances readability, makes the code easier to understand and maintain, and reduces the likelihood of errors. It is a key aspect of writing clean, well-structured code, and ignoring it can contribute to technical debt by making the codebase more cumbersome and error-prone.            |
| **Commented out code**                         | It refers to leaving unused or obsolete code within the codebase, merely commented out rather than being removed. It can clutter the code, making it harder to read and understand, and can lead to confusion about which parts of the code are active and which are not. Commented-out code should be removed, and if necessary, its history can be preserved in version control systems for future reference.                                                                                                                                            |
| **Exception handlers**                         | It refers to the inadequate handling of exceptions where the original error messages are not logged. This practice can obscure the underlying cause of an exception, making debugging and error resolution more difficult. Effective exception handling should include logging detailed error information, which is crucial for diagnosing and fixing issues promptly. Neglecting to log the original exception messages can lead to prolonged system downtime and more complex maintenance, thus contributing to technical debt.                          |
| **Generic exceptions**                         | It refers to using broad, non-specific exception types in error handling rather than more specific, descriptive exceptions. This practice can make error diagnosis and handling less effective, as it doesn't provide clear insight into the exact nature of an error. Using specific exceptions helps accurately identify the root cause of issues and allows for more precise and effective error handling, leading to more robust and maintainable code.                                                                                                |
| **Floating point equality**                    | It pertains to the challenges of comparing floating-point numbers directly for equality due to their inherent imprecision. Floating-point arithmetic can lead to rounding errors, making direct equality checks unreliable. Instead, best practices involve using a threshold of tolerance for equality checks or alternative methods that can handle the imprecision in floating-point calculations.                                                                                                                                                      |
| **Direct use of standard outputs for logging** | It refers to using basic output commands (like `print` in Python or `System.out.println` in Java) for logging purposes in a program. This method is typically discouraged as it lacks the features of specialized logging frameworks, such as categorizing log levels, filtering, or directing output to different destinations (like files or external systems). Utilizing dedicated logging systems provides more control, flexibility, and scalability in handling application logs.                                                                    |
| **Synchronized classes**                       | It refers to using older (Java) classes relying on synchronization. They can significantly hinder performance, especially in concurrent environments, as they lead to contention and reduced throughput. For instance, modern Java programming encourages using newer, more efficient concurrency mechanisms optimizing performance and scalability.                                                                                                                                                                                                       |
| **Empty methods**                              | It refers to methods defined without executable statements. These methods can be confusing, as they serve no functional purpose and can mislead developers into thinking they perform operations. They may be remnants of incomplete implementations or refactoring.                                                                                                                                                                                                                                                                                       |
| **Hardcoded secrets**                          | It refers to embedding sensitive information, such as passwords, API keys, or cryptographic keys, directly in the source code. This approach is risky because it exposes critical data to anyone who can access the code, potentially leading to security breaches. Proper handling involves externalizing and managing them through secure, centralized systems.                                                                                                                                                                                          |
| **Lack of Input Validation**                   | It refers to the failure to properly check, sanitize, or validate data received from user inputs or external sources before processing it. This oversight can leave software vulnerable to various forms of attack, such as SQL injection, cross-site scripting, or buffer overflows.                                                                                                                                                                                                                                                                      |
| **Insufficient Error Handling**                | It refers to the inadequate management of errors (failing to properly catch, log, or handle exceptions, leading to unpredictable behavior, crashes, or security vulnerabilities). Effective error handling is essential not only for system stability but also for preventing the exploitation of error conditions by malicious actors.                                                                                                                                                                                                                    |
| **Improper Session Management**                | It refers to the inadequate handling and protection of user session data in applications (flaws in creating, maintaining, and terminating sessions, potentially leading to unauthorized access or session hijacking). Effective session management ensures secure and proper handling of session identifiers and related data, maintaining the integrity and confidentiality of user sessions throughout their lifecycle.                                                                                                                                  |
| **Insecure Default Settings**                  | It refers to using default configurations and components unsecured. These settings might include weak passwords, open network ports, or permissive file permissions. They pose a significant risk as they are often well-known and easily exploitable by attackers.                                                                                                                                                                                                                                                                                        |
| **Lack of Principle of Least Privilege**       | It pertains to granting more access rights or permissions to users, systems, or programs than necessary for their function. This oversight can lead to an increased risk of malicious activities or accidental system damage, as it provides a broader scope for exploiting these excess privileges.                                                                                                                                                                                                                                                       |
| **Insecure Direct Object References**          | It occurs when an application provides direct access to objects based on user-supplied input. It can lead to unauthorized access or manipulation of files, databases, or other resources if proper authorization checks are not in place. It's crucial for applications to implement robust access control and verification mechanisms to prevent such security vulnerabilities, ensuring that users can only access objects for which they have the appropriate permissions.                                                                              |
| **Cross-Site Request Forgery (CSRF)**          | It refers to the debt leading to the CSRF security vulnerability, where an attacker tricks a user into executing unwanted actions on a web application where they are authenticated. This attack can compromise the integrity of user interactions with the application, leading to unauthorized or harmful actions being performed without the user's knowledge. It's essential for applications to implement anti-CSRF tokens and other protective measures to prevent such attacks and safeguard user operations within their systems.                  |
| **Ignoring Security Warnings**                 | It refers to overlooking or dismissing warnings generated by security tools or systems. It can include bypassing compiler warnings, security alerts, or best practice recommendations. Ignoring these warnings can leave known vulnerabilities unaddressed in the code, potentially leading to security breaches and system compromises.                                                                                                                                                                                                                   |
| **Not Adhering to Secure Coding**              | It refers to disregarding established guidelines and best practices for writing secure code. This non-compliance can lead to vulnerabilities in the software, as secure coding standards are designed to prevent common security risks like injection attacks, data leaks, and unauthorized access.                                                                                                                                                                                                                                                        |

## Technical debt instances

The number for technical debt identified within the repositories are the following:

| Category                                       | Batik | JXPath | Airflow |
|------------------------------------------------|-------|--------|---------|
| **Duplicated String literals**                 | 113   | 66     | 486     |
| **Duplicated code blocks**                     | 0     | 0      | 0       |
| **Nested flow statements**                     | 149   | 142    | 21      |
| **Collapsible "if" statements**                | 29    | 22     | 0       |
| **Long method**                                | 149   | 125    | 58      |
| **Complex Method**                             | 98    | 103    | 32      |
| **Long parameter list**                        | 24    | 9      | 32      |
| **Too many lines in switch case**              | 49    | 40     | 0       |
| **Poor Code Formatting**                       | 0     | 0      | 0       |
| **Commented out code**                         | 0     | 0      | 16      |
| **Exception handlers**                         | 273   | 151    | 51      |
| **Generic exceptions**                         | 55    | 35     | 54      |
| **Floating point equality**                    | 0     | 0      | 0       |
| **Direct use of standard outputs for logging** | 1     | 0      | 2       |
| **Synchronized classes**                       | 11    | 20     | 0       |
| **Empty methods**                              | 80    | 3      | 10      |
| **Hardcoded secrets**                          | 0     | 0      | 0       |
| **Insecure Dependencies**                      | 0     | 0      | 0       |
| **Lack of Input Validation**                   | 0     | 2      | 0       |
| **Insufficient Error Handling**                | 0     | 0      | 0       |
| **Inadequate Encryption**                      | 0     | 0      | 0       |
| **Improper Session Management**                | 0     | 0      | 5       |
| **Insecure Default Settings**                  | 0     | 0      | 0       |
| **Lack of Principle of Least Privilege**       | 0     | 0      | 0       |
| **Insecure Direct Object References**          | 0     | 0      | 0       |
| **Cross-Site Request Forgery (CSRF)**          | 0     | 0      | 0       |
| **Ignoring Security Warnings**                 | 0     | 0      | 0       |
| **Not Adhering to Secure Coding**              | 0     | 0      | 0       |
